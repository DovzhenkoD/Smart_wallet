==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №5, №6: "Символьні пристрої"
_________________________________________

Зміст
_____
	#. `Завдання`_
	#. `Теоретичні відомості`_
		#. `Символьні пристрої`_
		#. `lseek()`_
	#. `Хід роботи`_
		#. `Виконання TO DO`_	
		#. `Інші функції`_


Завдання
~~~~~~~~

Теоретичні відомості
____________________

Символьні пристрої
~~~~~~~~~~~~~~~~~~

Спосіб бачення пристроїв в `Linux` розділяється на *три фундаментальні типи*. Кожен модуль зазвичай реалізований як один з цих типів і таким чином класифікується як **символьний модуль**, **блочний модуль**, або **мережевий модуль**. Такий поділ модулів на різні типи або класи не є жорстким; програміст може при бажанні створювати великі модулі, що містять різні драйвера в одному частині коду.

**Символьний пристрій** - це таке пристроїв, до якого можна звертатися як до потоку байтів (так само як до файлу). Драйвер символьного пристрою відповідає за реалізацію такої поведінки. Такий драйвер, зазвичай,  підтримує системні виклики, такі як: *open*, *close*, *read* і *write*. Прикладами символьних пристроїв є: текстовий екран ``(/dev/console)`` і послідовні порти ``(/dev/ttyS0 і подібні)``. Для звернення до символьних пристроїв використовують вузли *(node)* файлової системи, такі як ``/dev/tty1`` і ``/dev/lp0``. Єдине **важлива відмінність** між символьними пристроями і звичайними файлами - це можливість рухатися вперед і назад у *звичайному файлі*, в той час як більшість *символьних пристроїв* - це тільки канали даних, в яких існує спосіб звертатися лише послідовно.

Файл пристрої ``/dev/ttyS0`` послідовного порту:

.. code-block:: c

	crw-rw---- 1 root uucp 4, 64 окт  7  2019 /dev/ttyS0

Перший символ в розширеному виведенні ``ls (ls -l)`` для символьних пристроїв - буква *c (character)*. Замість розміру файлу в п'ятому полі таблиці показується два числа - **мажорний** і **мінорний** номер пристрою *(major and minor numbers)*. Перший номер відображає *тип пристрою*, а другий - *номер пристрою в системі або режим його роботи*.

Структура **file_operations** визначена у файлі ``linux/fs.h`` і містить вказівники на функції драйвера, які відповідають за виконання різних операцій з пристроєм. Наприклад, практично будь-який драйвер символьного пристрою реалізує функцію читання даних з пристрою. Адреса цієї функції, серед усього іншого, зберігається в структурі **file_operations**.

Структура **file_operations** в нашому випадку частково ініціалізована, а решта ініціалізується ядром після виклику ``cdev_init()``.

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};



Хід роботи
__________

Одним з перших шагів, який необхідний зробити свій драйвер із встановленням символічного пристрою, є напівпровідність одного або декількох номерів пристроїв для роботи з ними. Необхідною функцією для виконання цих завдань є register_chrdev_region, який розміщується в ``<linux/fs.h>``:


Виконання TO DO
~~~~~~~~~~~~~~~
	
	#. `TODO: change this to proper associative array or tree`_
	#. `TODO: fix to make it zero'ed first`_
	#. `TODO: Add buffer read logic. Make sure seek operations work`_
	#. `TODO: Add buffer write logic. Make sure seek operations work`_
	#. `TODO: add ioctl to append magic phrase to buffer conents to make these bees twerk`_
	#. `TODO: add ioctl to select buffer size`_
	#. `TODO: add stuff here to make module register itself in /dev`_

TODO: change this to proper associative array or tree
"""""""""""""""""""""""""""""""""""""""""""""""""""""

TODO: fix to make it zero'ed first
""""""""""""""""""""""""""""""""""

До виправлення:

.. code-block:: c

	char *buf = kmalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Після виправлення:

.. code-block:: c

	char *buf = kzalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Кодова база ядра містить багато функцій, які виділяють пам'ять за допомогою **kmalloc ()**, а потім обнуляют її за допомогою **memset ()**. Згодом Пекка Енберг прийшов до висновку, що більшу частину цього коду можна очистити за допомогою **kcalloc ()**.

**kcalloc ()** має цей прототип:

.. code-block:: c

	void * kcalloc (size_t n, size_t size, unsigned int __nocast gfp_flags);

Але тут є один недолік: далеко не всі викликаючі абоненти фактично повинні виділити масив елементів, тому в більшості випадків додатковий аргумент **size_t n** не потрібно. Кожен екземпляр цього аргументу додає деякий об'єм до розміру ядра, і з часом цей простір збільшується. Тому Ендрю Мортон запропнував нове рішення створити ще одну функцію розподілу:

.. code-block:: c

	void * kzalloc (size_t size, unsigned int __nocast gfp_flags);

Ця функція повертає один обнулений елемент.

TODO: Add buffer read logic. Make sure seek operations work
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: c
	
	unsigned long copy_to_user (void __user *to,
 		const void *from,
		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі користувача;
		* **from** - адреса джерела в просторі ядра;
		* **n** - кількість байтів для копіювання.

Короткий опис::
	Тільки контекст користувача Ця функція може спати.
	Скопіюйте дані з простору ядра в простір користувача.
	Повертає кількість байтів, які неможливо скопіювати. При успіху це буде нуль.
	
TODO: Add buffer write logic. Make sure seek operations work
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Копіювання даних з постору користувача відбувається за допомогою наступної команди:

.. code-block:: c

	unsigned long copy_from_user (void* to,
 		const void __user *from,
 		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі ядра;
		* **from** - адреса джерела в просторі користувача;
		* **n** - кількість байтів для копіювання.



Короткий опис::
	Тільки для користувача контекст. Ця функція може спати. 
	Копіює дані з простору користувача в простір ядра.
	Повертає кількість байтів, які не вдалося скопіювати. У разі успіху це буде нуль.

Команда повертує **нульове** значення вразі успішного виконання. 
Написана функці наведена нижче:

.. code-block:: c



Для того, щоб запезпечувалося читання та запис в пристрій, вирішено добавити функцію `lseek()`_. 


TODO: add ioctl to append magic phrase to buffer conents to make these bees twer
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

TODO: add ioctl to select buffer size
"""""""""""""""""""""""""""""""""""""

TODO: add stuff here to make module register itself in /dev
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Для того, щоб використовувати *character driver*, спершу слід зареєструвати його в системі. Потім - виставити його в *user space*.

	* ``cdev_init()`` - ініціалізувати структуру **cdev**;
	* ``cdev_add()`` - додати символьний пристрій до системи;
	* ``class_create()`` - створює новий клас пристроїв для пристрою;
	* ``device_create()`` - створює пристрій та реєструє його за допомогою *sysfs*.
	
Функції **cdev_init()** та **cdev_add()** виконують реєстрацію символьних пристроїв. 
Коли функція **cdev_add** успішно виконується, пристрій працює в режимі живого і ядро ​​може викликати свої операції.

Щоб отримати доступ до цього пристрою з простору користувача, слід створити вузол пристрою в ``/dev``. Для цього потрібно створити клас віртуального пристрою за допомогою **class_create()**, слід його зареєєструвати в  ``sysfs`` за допомогою функції **device_create()**. 
**device_create** створить файл пристрою в ``/dev``.

Для початку використання всіх вище перерахованих функцій потрібно підключити ``#include <linux/cdev.h>``, де і відбувається визначення структури, а також пов'язані з нею допоміжні функції.


Інші функції
~~~~~~~~~~~~
	#. `lseek()`_

lseek()
"""""""

``lseek()`` - встановити зміщення для позиціонування операцій *читання/запису*.

.. code-block:: c

	off_t lseek(int fd, off_t offset, int whence);

Змінює поточну позицію читання / запису в файлі, в заданому дескрипторі *fd*. Параметр *whence* може приймати одне з наступних значень:

	* SEEK_SET
              Зміщення вставновлює в **offset** байт від початку файлу.

	* SEEK_CUR
              Зміщення встановлює на **offset** байт відносно заданої позиції

	* SEEK_END
              Зміщення встановлюється, як розмір файду + **offset** байт.

При успішному виконані **lseek** повертає зміщення в байтах нової позиції відносно початку файлу. В іншому випадку, повертається значення **(off_t) -1** і errno показує помилки.

**Основні помилки:**

* EBADF  **fd** не є дескриптором відкритого файлу.
* EINVAL **whence** не є одним із значень*SEEK_SET, SEEK_CUR, SEEK_END* або ж зміщення у файлі, яке вийшло в результаті є від'ємним.

Реалізаціє виглядає наступним чином:

.. code-block:: c

static loff_t cdev_lseek(struct file *file, loff_t offset, int orig)
{
	loff_t new_offset = 0;
	
	switch(orig) {
	case SEEK_SET: new_offset = offset; break;
	case SEEK_CUR: new_offset = file->f_pos + offset; break;
	case SEEK_END: new_offset = buffsize - offset; break;
	}
	file->f_pos = new_offset;
	return new_offset;

}



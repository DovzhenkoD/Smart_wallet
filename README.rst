==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №5, №6: "Таймера та ворки"
_________________________________________

Зміст
_____
	#. `Завдання`_
	#. `Теоретичні відомості`_
		#. `Символьні пристрої`_
	#. `Хід роботи`_
		#. `Виконання TO DO`_	


Завдання
~~~~~~~~

Теоретичні відомості
____________________

Символьні пристрої
~~~~~~~~~~~~~~~~~~

Спосіб бачення пристроїв в `Linux` розділяється на *три фундаментальні типи*. Кожен модуль зазвичай реалізований як один з цих типів і таким чином класифікується як **символьний модуль**, **блочний модуль**, або **мережевий модуль**. Такий поділ модулів на різні типи або класи не є жорстким; програміст може при бажанні створювати великі модулі, що містять різні драйвера в одному частині коду.

**Символьний пристрій** - це таке пристроїв, до якого можна звертатися як до потоку байтів (так само як до файлу). Драйвер символьного пристрою відповідає за реалізацію такої поведінки. Такий драйвер, зазвичай,  підтримує системні виклики, такі як: *open*, *close*, *read* і *write*. Прикладами символьних пристроїв є: текстовий екран ``(/dev/console)`` і послідовні порти ``(/dev/ttyS0 і подібні)``. Для звернення до символьних пристроїв використовують вузли *(node)* файлової системи, такі як ``/dev/tty1`` і ``/dev/lp0``. Єдине **важлива відмінність** між символьними пристроями і звичайними файлами - це можливість рухатися вперед і назад у *звичайному файлі*, в той час як більшість *символьних пристроїв* - це тільки канали даних, в яких існує спосіб звертатися лише послідовно.

Файл пристрої `/dev/ttyS0` послідовного порту:

.. code-block:: c

	crw-rw---- 1 root uucp 4, 64 окт  7  2019 /dev/ttyS0

Перший символ в розширеному виведенні ``ls (ls -l)`` для символьних пристроїв - буква *c (character)*. Замість розміру файлу в п'ятому полі таблиці показується два числа - **мажорний** і **мінорний* номер пристрою *(major and minor numbers)*. Перший номер відображає *тип пристрою*, а другий - *номер пристрою в системі або режим його роботи*.

Структура **file_operations** визначена у файлі ``linux/fs.h`` і містить вказівники на функції драйвера, які відповідають за виконання різних операцій з пристроєм. Наприклад, практично будь-який драйвер символьного пристрою реалізує функцію читання даних з пристрою. Адреса цієї функції, серед усього іншого, зберігається в структурі **file_operations**.

Структура **file_operations** в нашому випадку частково ініціалізована, а решта ініціалізується ядром після виклику ``cdev_init()``.

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};

Хід роботи
~~~~~~~~~~

Одним з перших шагів, який необхідний зробити свій драйвер із встановленням символічного пристрою, є напівпровідність одного або декількох номерів пристроїв для роботи з ними. Необхідною функцією для виконання цих завдань є register_chrdev_region, який розміщується в <linux / fs.h>:


Виконання TO DO
~~~~~~~~~~~~~~~
	
	#. `TODO: fix to make it zero'ed first`_
	#. `TODO: add stuff here to make module register itself in /dev`_


TODO: fix to make it zero'ed first
""""""""""""""""""""""""""""""""""

До виправлення:

.. code-block:: c

	char *buf = kmalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Після виправлення:

.. code-block:: c

	char *buf = kzalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Кодова база ядра містить багато функцій, які виділяють пам'ять за допомогою **kmalloc ()**, а потім обнуляют її за допомогою **memset ()**. Згодом Пекка Енберг прийшов до висновку, що більшу частину цього коду можна очистити за допомогою **kcalloc ()**.

**kcalloc ()** має цей прототип:

.. code-block:: c

	void * kcalloc (size_t n, size_t size, unsigned int __nocast gfp_flags);

Але тут є один недолік: далеко не всі викликаючі абоненти фактично повинні виділити масив елементів, тому в більшості випадків додатковий аргумент **size_t n** не потрібно. Кожен екземпляр цього аргументу додає деякий об'єм до розміру ядра, і з часом цей простір збільшується. Тому Ендрю Мортон запропнував нове рішення створити ще одну функцію розподілу:

.. code-block:: c

	void * kzalloc (size_t size, unsigned int __nocast gfp_flags);

Ця функція повертає один обнулений елемент.

TODO: add stuff here to make module register itself in /dev
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Для того, щоб використовувати *character driver*, спершу слід зареєструвати його в системі. Потім - виставити його в *user space*.

	* ``cdev_init()`` - ініціалізувати структуру **cdev**;
	* ``cdev_add()`` - додати символьний пристрій до системи;
	* ``class_create()`` - створює новий клас пристроїв для пристрою;
	* ``device_create()`` - створює пристрій та реєструє його за допомогою *sysfs*.
	
Функції **cdev_init()** та **cdev_add()** виконують реєстрацію символьних пристроїв. 
Коли функція **cdev_add** успішно виконується, пристрій працює в режимі живого і ядро ​​може викликати свої операції.

Щоб отримати доступ до цього пристрою з простору користувача, слід створити вузол пристрою в ``/dev``. Для цього потрібно створити клас віртуального пристрою за допомогою **class_create()**, слід його зареєєструвати в  ``sysfs`` за допомогою функції **device_create()**. 
**device_create** створить файл пристрою в ``/dev``.

Для початку використання всіх вище перерахованих функцій потрібно підключити ``#include <linux/cdev.h>``, де і відбувається визначення структури, а також пов'язані з нею допоміжні функції.





==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №3: "Продовженя написання модулей ядра"
__________________________________________________________

Зміст
_____

	#. `Теоритичні відомості`_
		#. `Механізм потоків ядра`_
		#. `Списки в ядрі Linux`_
		#. `Функція kmalloc()`_
	#. `Хід роботи`_
		#. `Реалізація потоків`_
		#. `Реалізація списків`_
		

Теоритичні відомості
~~~~~~~~~~~~~~~~~~~~

Механізм потоків ядра
"""""""""""""""""""""

*Що таке ядро?* Було розглянуто в `попередній л.р. <https://github.com/kpi-keoa/kpi-embedded-linux-course/blob/master/dk62_dovzhenko/lab2_simplest_kernel_modules/README.rst>`_

Часто в ядрі корисно виконати деякі операції у фоновому режимі. В ядрі така можливість реалізована за допомогою потоків простору ядра *kernel thread* - звичайних процесів, які виконуються виключно в просторі ядра.

**Механізм потоків ядра** (kernel thread - з'явився, починаючи з версії ядра 2.5) надає засіб для паралельного виконання завдань в ядрі.

**Реалізація потоків в ядрі Linux**

Реалізація потоків в операційній системі Linux є унікальною, оскільки для такого ядра не існує як такої окремої концпції потоків. В ядрі Linux потоки реалізовані так само, як і *звичайні процеси*.

**Поток** - це просто такий процес, який використовує деякі ресурси разом із іншими процесами.

Реалізація потоків виконана нижче - `Реалізація потоків`_.

Списки в ядрі Linux
"""""""""""""""""""
Ядро linux написано переважно на мові С.

Раніше в ядрі було кілька реалізацій зв'язних списків. Проте для того, щоб прибрати різний код, який виконує однакові дії, потрібно, щоб існувала єдина реалізація списків. Під час розробки серії *ядер 2.1* була запропонована єдина реалізація зв'язаних списків в ядрі. Сьогодні у всіх підсистемах ядра використовується офіційна реалізація(циклічний двухзв'язний список).

**Зв'язаний список** - це структура зберігання інформації (контейнер), яка може містити змінну кількість елементів даних, що їх називають вузлами, і дозволяє маніпулювати цими даними.

Двозхвязні списки *(doubly linked)* містять вказівник не лише на наступний елемент *next*, але й на попередній *prev*. 

  .. image:: img/doubly _linked.jpg

Останній елемент зв'язаного списку не має наступного за ним елемента, і значення вказівника *next* останнього елемента зазвичай встановлюється рівним спеціальному значенням *NULL*, для того щоб показати, що цей елемент списку є останнім. В деяких випадках останній елемент списку не вказує на спеціальне значення, а вказує на перший елемент цього ж списку. Такий список називається **кільцевих зв'язаним списком (circular linked list)**, оскільки зв'язок утворюють на кштал кільця.

  .. image:: img/circular_linked.jpg
  
  
Детальніше реалізація списків в даній лабораторній роботі розглянута в `Реалізація списків`_.


Функція kmalloc()
"""""""""""""""""

**Функція kmalloc()** - це простий інтерфейс для виділення в ядрі ділянок пам'яті розміром в задану кількість байтів.
Дана функція визначена у файлі ``<linux/slab.h>``.
Першим аргументом *kmalloc* є розмір блоку, який буде виділений. Другий аргумент, прапори виділення, вони контролює поведінку *kmalloc*.
Найбільш часто використовуваний флаг, **GFP_KERNEL**, означає, що виділення проводиться від імені процесу, запущеного в просторі ядра.

Хід роботи
~~~~~~~~~~

Реалізація потоків
""""""""""""""""""

Для роботи з потоками (kthread) необхідно заінклудити ``#include <linux/kthread.h>``.

Кожен поток має структуру ``task_struct``, і як вже говорилося поток представляється для ядра звичайним процесом (який спільно використовує ресурси, такі як адресний простір, з іншими процесами).

У функції ініціалізації модуля ``static int __init blablamod_init!!!!!!!!!!!!( void )`` необхідно запустити новий потік за допомогою функції ``kthread_run``.

.. code-block:: c

	kthread_run(thread_function, &i ,"thread_%d", i);

де, є такі аргументи:
	* *thread_function* - функція, яку потрібно запустити;
	* *&i* - дані, яку хочемо передати у функцію;
	* *"thread_%d", i* - ім'я для потоку.

Також дана функція, поверне вказівник на створений поток, який оголошується наступним чином:

.. code-block:: c
	
	struct task_struct *task;

	
В функції потока ``int thread_function(void *data)`` реалізовано цикл, який збільшує перемінну ``count`` на ``N`` разів.

Для того, щоб завершити поток потрібно викликати функцію: 

.. code-block:: C

	int kthread_stop( struct task_struct* );

В ролі розподільника задач обрано функцію ``schedule()``. Планувальник послідовно переключає процеси, даючи можливість кожному з них на якийсь час скористатися центральним процесором в своїх цілях.


Реалізація списків
""""""""""""""""""

Для реалізація циклічного двусвязного списку на *С* потрібно підключити ``#include <linux/list.h>``.

Даний файл визначає просту структуру типу *list_head*

.. code-block:: c

  struct list_head {
    struct list_head *next, *prev;
  };

Зв'язні списки, які використовуються в реальному коді, складаються зі структури одного типу, кожна з яких описує один запис в списку. Для використання в нашому коді засоби списку Linux, необхідно лише добавити *list_head* всередині структур, що входять до вже заданого списку. 

.. code-block:: c

  typedef struct my_struct_n {
	  struct list_head list;
	  int num;
	  struct task_struct *task;
  }my_struct;
	
``INIT_LIST_HEAD(&my.list);`` - такий макрос об'являє змінну типу *struct list_head* з вказаним ім'ям, а також ініціалізує її.
Замість даного макроса, можна використати *LIST_HEAD(mylist)*.

Для того, щоб додати новий елемент *pointer* в список потрібно викорстовувати: ``list_add(&pointer->list, &my.list);``.
Також є можливість добавляти елементи нові в "хвіст" списка, для цього є функція: ``list_add_tail()``.

В коді також використовується макрос ``list_for_each()``.  Він дозволяє ралізувати цикл проходження по елементам списку. Перший аргумент використовується, як лічильник. Тобто він використовується, для того щоб показати на покле типу *list_head* даного елемента списку. Другий аргмент - вказівник на список. Іншими словами цей макрос створює цикл **for**.

Наступний макрос, який розглянуто - це ``list_entry()``. В якості аргументів макрос приймає вказівни на структуру `struct list_head`, в якій зберігається позиція списку на даний момент. Макрос повертає вказівник на структуру, членом якого являється перший аргумент , іншими словами на який вказує перший аргумент - в нашому випадку *head*.

Для видалення запису із списка існує макрос ``list_del()``. Тому для того, щоб проходити по елементам списку, краще використовувати макрос, який предбачно використовувати для організації цикла, що передбачає видалення списку - ``list_for_each_safe()``.

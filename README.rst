==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №7
__________________________

Зміст
_____
	#. `Завдання`_
	#. `red-black tree`_
		#. `Теорія`_
		#. `Реалізація`_
			#. `Функція вставки`_
			#. `Створення нового rbtree`_
	#. `Трішки про Kconfig`_
	#. `Debugfs`_
		#. `Теорія`_
		#. `Використання debugfs`_
	#. `QEMU`_
	#. `GDB`_
	#. `Використанні джерела`_


Завдання
________

- разобраться с debugfs

– добавить к предыдущей лабораторной возможность читать и писать в буфферы с помощью debugfs (при открытии файла и аллокации буффера, в debugfs создается entry с именем в виде адреса file, содержимым в качестве blob)

– разобраться с отладкой модулей ядра средствами GDB

– попробовать отлаживать модуль hive средствами gdb на ядре, запущенном в qemu

– попробовать положить ядро, записать crash dump и затем исследовать его с помощью crash (вместо положить можно использовать sysrq)

– результаты двух предыдущих пунктов включить в отчет

– подготовиться продемонстрировать при защите

:Примітка: лабораторна робота заснована на виконанні  `попередньої <https://github.com/kpi-keoa/kpi-embedded-linux-course/tree/master/dk62_dovzhenko/lab5_6_character_device/>`_, проте в 5-6 роботі використовувалося звичайне бінарне дерево, а в даній буде використано дерево під назвою "червоно-чорне".


red-black tree
______________

Теорія
~~~~~~

Червоно-чорне дерево (англ. red-black tree, англ. RB tree) — різновид самозбалансованого бінарного дерева пошуку, вершини якого мають додаткові властивості (RB-властивості), зокрема «колір» (червоний або чорний). 

Бінарне дерево називається червоно-чорним, якщо воно має такі властивості:

#. кожна вершина або червона, або чорна
#. корінь дерева — чорний
#. кожний лист (NIL) — чорний
#. якщо вершина червона, обидві її дочірні вершини чорні (інакше, батько червоної вершини — чорний)
#. усі прості шляхи від будь-якої вершини до листів мають однакову кількість чорних вершин

Візуальний риклад такого дерева:

.. image:: img/red-black_tree_example.png

В деяких зображеннях червоно-чорних дерев, NIL-листки не наводяться, тому що вони не містять корисної інформації, але їхнє існування необхідне для забезпечення усіх властивостей.

Реалізація
~~~~~~~~~~

Функція вставки
"""""""""""""""

Потрібно проходити по дереву, поки не знайдено "листовий" вузол, де буде відбуватися вставка. Як тільки знайдено це місце, новий вузол вставляється як «червоний», і дерево при необхідності перебалансовується. Код реалізовано наступним чином:

.. code-block:: c

	void ftree_add (struct hive_flist_item *item, struct rb_root *root)
	{
		struct rb_node **link = &root->rb_node, *parent;
		struct file *val4cmp = item->file;
		while(*link) {
			parent = *link;
			struct hive_flist_item *strp = rb_entry(parent, struct hive_flist_item,
				node);
			if (strp->file > val4cmp)
				link = &(*link)->rb_left;
			else
				link = &(*link)->rb_right;
		}
		rb_link_node(&item->node, parent, link);
		rb_insert_color(&item->node, root);
	}


Щоб використовувати таке дерево слід підключити «#include <linux / rbtree.h>»

Створення нового rbtree
"""""""""""""""""""""""

Вузли даних в дереві rbtree - це структури, що містять елемент struct rb_node:

.. code-block:: c

	struct rb_node node;

При роботі з вказівником на вбудовану структуру rb_node доступ до структури даних можна отримати за допомогою стандартного макроса container_of (). Крім того, окремі члени можуть бути доступні безпосередньо через rb_entry (вузол, тип, член).

У корені кожного rbtree знаходиться структура rb_root, яка ініціалізується як порожня через:

.. code-block:: c

	struct rb_root the_root = RB_ROOT;

Трішки про Kconfig
__________________

Механізм **Kconfig** є сьогодні стандартним механізмом конфігурації і використовується провідними проектами з відкритим вихідним кодом, такими як *ядро Linux*, *Busybox* і *uClibc*. **Kconfig** має базовий синтаксис конфігурації, який дозволяє додавати параметри конфігурації різних типів, створювати залежності і писати кілька рядків опису.

Ядро Linux містить файл *Kconfig* майже для кожного каталогу. 
Кожен файл Kconfig налаштовує свій власний рівень.

**Деякі функції для конфігурації:** [2]_

* **make config** - текстова конфігурація. Параметри пропонуються один за одним. На всі варіанти потрібно відповісти, а доступ до попередніх опцій неможливий;

* **make menuconfig** - псевдо графічне меню на основі *ncurses* (лише введення тексту). Потрібно перейти до меню, щоб змінити потрібні параметри;

* **make defconfig** - створює новий конфігураційний файл з настройками за замовчуванням, які беруться з архітектурно-залежних *defconfig* файлів. Використовують цю опцію, щоб знову створити конфігураційний файл з налаштуваннями за замовчуванням, аналогічно як в архіві з вихідним кодом.

* **make nconfig** - псевдо графічне меню на основі ncurses. Потрібно встановити `sys-libs/ncurses <https://packages.gentoo.org/packages/sys-libs/ncurses>`_.

* **make xconfig** - конфігуратор з графічним інтерфейсом заснований на *Qt4*. потрібн підключити `<dev-qt/qtgui https://packages.gentoo.org/packages/dev-qt/qtgui>`_

* **make oldconfig** - переглядається відміність між версіями ядра та оновляється, щоб створити новий ``.config`` для ядра;

* **make allyesconfig** - вмикає всі параметри конфігурації в ядрі. Він встановлює для всіх параметрів ядра ``*``. **Потрібно переконатися, що перед використанням цієї опції отримано резервну копію поточної конфігурації ядра!**


Debugfs
_______

Теорія
~~~~~~	

:debugfs: - це спеціальна файлова система, доступна в ядрі *Linux* починаючи з версії 2.6.10-rc3.

Debugfs існує як простий спосіб для розробників ядра збирати інформацію доступно для робочих просторів. На відміну від ``/proc``, який призначений тільки для інформації про процес, або ``sysfs``, який має суворі правила одне значення для файлу, У ``debugfs`` немає ніяких правил. Розробники можуть розмістити будь-яку інформацію, яку бажають. 

**Існує багато функцій числових, булевих значень або фрагментів пам'яті (в основному текстових), ось дякі з них:** [1]_

``struct dentry * debugfs_create_u8 (const char * name, режим umode_t, struct dentry * parent, значение u8 *);`` - створює файл debugfs, який використовується для читання і запису 8-розрядного значення без знака;

``struct dentry *debugfs_create_bool(const char *name, umode_t mode, struct dentry *parent, bool *value);`` - створює файл debugfs, який використовується для читання і запису логічного значення;

``struct dentry *debugfs_create_blob(const char *name, umode_t mode, struct dentry *parent, struct debugfs_blob_wrapper *blob);`` - створює файл debugfs, який використовується для читання двійкового довічного об'єкта


Використання debugfs
~~~~~~~~~~~~~~~~~~~~

Код, що використовує debugfs, підключається за допомогою ``<linux/debugfs.h>``.
Перший кроков, це було створення католога в системі debugfs.

.. code-block:: c

	debugfs_folder = debugfs_create_dir(DIR, NULL);
	if (!debugfs_folder) {
		printk(KERN_INFO,"debugfs_folder creation failed!\n");
	}

Розглянемо функцію **debugfs_create_dir** детальніше:

.. code-block:: c

	struct dentry * debugfs_create_dir (const char *name, struct dentry *parent);

де,
	* *name* - вказівник на рядок, що містить ім'я каталогу для створення.
	* *parent* - вказівник на *батьківський* dentry для цього файлу. Це має бути каталог dentry, якщо він встановлений. Якщо цей параметр має значення **NULL**, каталог буде створений в корені файлової системи debugfs.

:Короткий опис: Ця функція створює каталог в *debugfs* із заданим ім'ям. Така функція поверне вказівнк на dentry, якщо все виконається без проблем.


Також було створено файл у файловій системі debugfs.

.. code-block:: c

	debugfs_file = debugfs_create_file(FILE, 0777, debugfs_folder, NULL, &debugfs_fops);

.. code-block:: c

	struct dentry * debugfs_create_file (const char *name,
 		mode_t mode,
 		struct dentry *parent,
 		void *data,
 		const struct file_operations *fops);

де,
	* *name* - вказівник на рядок, що містить ім'я файлу для створення;
	* *mode* - права файлу;
	* *parent* - вказівник на "батьківський" dentry для цього файлу. Це повинен бути каталог dentry, якщо він встановлений. Якщо цей параметр має значення NULL, файл буде створений в корені файлової системи debugfs.
	* *data* - вказіваник на те, що отримувач захоче отримати пізніше.
	* *fops* - вказівник на *struct file_operations*, яка повинна використовуватися для цього файлу.


Було і використано функцію видалення катлогу

.. code-block:: c

	void debugfs_remove_recursive (struct dentry * dentry);

де,
	* *dentry* - вказівник на каталог, який потрібно видалити.
	
:Короткий опис: ця функція рекурсивно видаляє дерево каталогів у debugfs, які були створені дещо раніше за допомогою виклику інших функцій debugfs (наприклад, *debugfs_create_file* або її варіантів)

Структура *file_operations* виглядає наступним чином:

.. code-block:: c

	static struct file_operations debugfs_fops = {
		.open =		&debugfs_open,
		.release =		&debugfs_release,
		.read =		&debugfs_read,
		.write =		&debugfs_write,
	};

QEMU
____


:QEMU: вільна програма з відкритим вихідним кодом для емуляції апаратного забезпечення різних платформ.

Програма може працювати в **Windows**, **Linux**, **MacOS** і навіть на **Android**.

**QEMU може емулювати такі архітектури**
	* x86 (32 і 64 біт);
	* ARM, SPARC;
	* PowerPC (32 і 64 біт);
	* MIPS, m68k (Coldfire);
	* SH-4;
	* CRISv2;
	* Alpha;
	* MicroBlaze.

**Програма QEMU мають наступні переваги та особливості:**

#. Може зберігати і відновити стан віртуальної машини з усіма запущеними програмами. Гостьовий операційній системі не потрібно патчів для запуску всередині QEMU.
#. Не потрібні прав адміністратора для запуску, якщо не використовуються додаткові модулі ядра для підвищення швидкості (наприклад, KQEMU), або коли використовуються деякі режими його моделі підключення до мережі.
#. Підтримує два режими емуляції: призначений для користувача режим ``[User-mode]`` і системний режим ``[System-mode]``.
		* Призначений для користувача режим емуляції дозволяє процесу, створеному на одному процесорі, працювати на іншому (виконується динамічний переклад інструкцій для приймаючої процесора і конвертація системних викликів Linux).
		* Системний режим емуляції дозволяє емулювати систему цілком, включаючи процесор і різноманітну периферію.

GDB
___

GDB, відладчик проекту GNU, дозволяє вам бачити, що відбувається "всередині" інший програми під час її виконання - або що інша програма робила в момент її збою.

GDB може виконувати дії чотирьох основних типів, для того щоб допомогти виявити помилку:

* Почати виконання програми, перед цим задати все, що може вплинути на її поведінку;
* Зупинити програму при зазначених умовах;
* Дослідити, чому програма зупинилася;
* Змінити програму, так щоб була можливість експериментувати з усуненням ефектів однієї помилки і продовжити виявлення інших.



Використанні джерела
____________________

..[1] https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt
..[2] https://wiki.gentoo.org/wiki/Kernel/Configuration
..[3] https://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html


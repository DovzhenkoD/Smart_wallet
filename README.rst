==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №5, №6: "Символьні пристрої"
_________________________________________

Зміст
_____
	#. `Завдання`_
	#. `Теоретичні відомості`_
		#. `Символьні пристрої`_
		#. `Інше`_
	#. `Хід роботи`_
		#. `Виконання TO DO`_	
	#. `Результати`_


Завдання
~~~~~~~~

Теоретичні відомості
____________________

Символьні пристрої
~~~~~~~~~~~~~~~~~~

Спосіб бачення пристроїв в `Linux` розділяється на *три фундаментальні типи*. Кожен модуль зазвичай реалізований як один з цих типів і таким чином класифікується як **символьний модуль**, **блочний модуль**, або **мережевий модуль**. Такий поділ модулів на різні типи або класи не є жорстким; програміст може при бажанні створювати великі модулі, що містять різні драйвера в одному частині коду.

**Символьний пристрій** - це таке пристроїв, до якого можна звертатися як до потоку байтів (так само як до файлу). Драйвер символьного пристрою відповідає за реалізацію такої поведінки. Такий драйвер, зазвичай,  підтримує системні виклики, такі як: *open*, *close*, *read* і *write*. Прикладами символьних пристроїв є: текстовий екран ``(/dev/console)`` і послідовні порти ``(/dev/ttyS0 і подібні)``. Для звернення до символьних пристроїв використовують вузли *(node)* файлової системи, такі як ``/dev/tty1`` і ``/dev/lp0``. Єдине **важлива відмінність** між символьними пристроями і звичайними файлами - це можливість рухатися вперед і назад у *звичайному файлі*, в той час як більшість *символьних пристроїв* - це тільки канали даних, в яких існує спосіб звертатися лише послідовно.

Файл пристрої ``/dev/ttyS0`` послідовного порту:

.. code-block:: c

	crw-rw---- 1 root uucp 4, 64 окт  7  2019 /dev/ttyS0

Перший символ в розширеному виведенні ``ls (ls -l)`` для символьних пристроїв - буква *c (character)*. Замість розміру файлу в п'ятому полі таблиці показується два числа - **мажорний** і **мінорний** номер пристрою *(major and minor numbers)*. Перший номер відображає *тип пристрою*, а другий - *номер пристрою в системі або режим його роботи*.

Структура **file_operations** визначена у файлі ``linux/fs.h`` і містить вказівники на функції драйвера, які відповідають за виконання різних операцій з пристроєм. Наприклад, практично будь-який драйвер символьного пристрою реалізує функцію читання даних з пристрою. Адреса цієї функції, серед усього іншого, зберігається в структурі **file_operations**.

Структура **file_operations** в нашому випадку частково ініціалізована, а решта ініціалізується ядром після виклику ``cdev_init()``.

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};

Інше
~~~~

	#. `register_chrdev_region()`_
	#. `alloc_chrdev_region()`_
	#. `lseek()`_
	#. `file_operations()`_
	#. `ioctl()`_

register_chrdev_region()
""""""""""""""""""""""""

Одніціє з найперших дій, які потрібно зробити драйверу при створенні символьного пристрою, це отримати один або декілька номер пристроїв для роботи з ним. Саме функція **register_chrdev_region()** виконує цю задачу. Вона знаходиться у ``#include <linux/fs.h>``.

.. code-block:: c

	int register_chrdev_region(dev_t first, unsigned int count, char *name);

де

* **first** - це перший в бажаному діапазоні номер пристрою;
* **count** - необхідна кількість послідовних номерів пристрою;
* **name** - назва пристрою або є драйверу.

Як і в більшості функцій ядра, дана функція буде повертати **0**, якщо операція виділення успішно виконалася. В протилежному випадку, коли виникла помилка, то буде повернуто від'ємне значення.

Проте, дуже часто може бути така ситуація, що невідомо які старші номера пристрою будуть використовуватися. Тому в такому випадку, ядро може саомтійсно виділяти старший номер, для цього використовуєтьс/ функція `alloc_chrdev_region()`_

alloc_chrdev_region()
"""""""""""""""""""""

.. code-block:: c

	int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

де 

* **dev** - вихідний параметр для першого присвоєного числа;
* **firstminor** - містить значення першого молодшого номера для використання;
* **count** - необхідна кількість послідовних номерів пристрою;
* **name** -  назва пристрою або є драйверу.

Короткий опис:
	Функція виділяє діапазон номерів сивольних пристроїв. Основне число буде вибиратися динамічко, і повертаєтьсяв 
	dev/ Відповідно при успішній роботі повертає **0**, а при помилці - від'ємне значення.

lseek()
"""""""

``lseek()`` - встановити зміщення для позиціонування операцій *читання/запису*.

.. code-block:: c

	off_t lseek(int fd, off_t offset, int whence);

Змінює поточну позицію читання / запису в файлі, в заданому дескрипторі *fd*. Параметр *whence* може приймати одне з наступних значень:

* SEEK_SET
	Зміщення вставновлює в **offset** байт від початку файлу.
* SEEK_CUR
        Зміщення встановлює на **offset** байт відносно заданої позиції
* SEEK_END
        Зміщення встановлюється, як розмір файду + **offset** байт.

При успішному виконані **lseek** повертає зміщення в байтах нової позиції відносно початку файлу. В іншому випадку, повертається значення **(off_t) -1** і errno показує помилки.

**Основні помилки:**

* EBADF  **fd** не є дескриптором відкритого файлу.
* EINVAL **whence** не є одним із значень *SEEK_SET, SEEK_CUR, SEEK_END* або ж зміщення у файлі, яке вийшло в результаті є від'ємним.

Реалізаціє виглядає наступним чином:

.. code-block:: c

	static loff_t cdev_lseek(struct file *file, loff_t offset, int orig)
	{
		loff_t new_offset = 0;	
		switch(orig) {
		case SEEK_SET: 
			new_offset = offset; 
			break;
		case SEEK_CUR: 
			new_offset = file->f_pos + offset;
			break;
		case SEEK_END: 
			new_offset = buffsize - offset; 
			break;
		default:
			new_offset =  EINVAL;
		}
		file->f_pos = new_offset;
		return new_offset;
	}


file_operations()
"""""""""""""""""

Розглянемо коротко, що таке **file_operations**.

Структура **file_operations** оголошена у файлах ``linux/fs.h``.
Структура являє собою масив вказівників, на різні функції. Операції зазвичай, відповідають за реалізацію системних викликів.

Драйвер в більшості випадків, реалізує не всі функції, в заданій структурі. Для кожної конкретної задачі, потрібний свій список функцій.
Нижче наведенно, які саме операції будуть використані в даній лабораторній роботі:

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		.llseek =   &cdev_lseek,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};

Функції, які не використано заповнюються "пустими" вказівниками - **NULL**.

ioctl()
"""""""

Системний виклик **ioctl()** - це універсальний засіб управління апаратними пристроями.

Завдяки запитам **ioctl()** можна керувати багатьма оперативними характеристиками спеціальних символьних файлів.

Для використання такої функцій. слід підключити ``<linux/ioctl.h>``.

.. code-block:: c
	int ioctl(int fd, int cmd, ...);

Завдяки невизначеному списку параметрів, даний прототип сильно виділяється із списку системних викликів *Unix*, які, зазвичай, представлені фіксованим числом формальних параметрів. Однак, в реальній системі, системний виклик не може мати змінне число параметрів. Системні виклики повинні мати чітко визачену кількість аргументів, так як призначені для користувача програми можуть отримати доступ до них тільки через апаратну частину.

**Першим аргументом** функції є дескриптор файлу того пристрою, яким потрібно керувати. **Другий аргумент** - це код запиту, що позначає операцію, що буде виконуватися. Різним пристроям відповідають різні запити. Залежно від запиту функції **ioctl()** можуть знадобитися додаткові аргументи. **Третій аргумент** - нетипізований вказівник на пам'ять. Це традиційно **char * argp**.

Зазвичай, при успішному завершенні роботи повертається нуль. У деяких **ioctl()** запитах повернене значення вважається вихідним параметром і при успішному завершенні повертається позитивне значення. У разі помилки повертається **-1** і значення **errno** встановлюється відповідним чином. 
Основні помилки:

*  **EBADF** - **fd** не є дескриптором відкритого файлу.
*  **ENOTTY** - **fd** не пов'язаний з символом спеціального пристрою.
*  **ENOTTY** - вказаний запит не застосовується до виду об'єкта.
*  **EFAULT** - **argp** посилається на недоступну область пам'яті.

Хід роботи
__________

Одним з перших шагів, який необхідний зробити свій драйвер із встановленням символічного пристрою, є напівпровідність одного або декількох номерів пристроїв для роботи з ними. Необхідною функцією для виконання цих завдань є register_chrdev_region, який розміщується в ``<linux/fs.h>``:


Виконання TO DO
~~~~~~~~~~~~~~~
	
	#. `TODO: change this to proper associative array or tree`_
	#. `TODO: fix to make it zero'ed first`_
	#. `TODO: Add buffer read logic. Make sure seek operations work`_
	#. `TODO: Add buffer write logic. Make sure seek operations work`_
	#. `TODO: add ioctl to append magic phrase to buffer conents to make these bees twerk`_
	#. `TODO: add ioctl to select buffer size`_
	#. `TODO: add stuff here to make module register itself in /dev`_

TODO: change this to proper associative array or tree
"""""""""""""""""""""""""""""""""""""""""""""""""""""

TODO: fix to make it zero'ed first
""""""""""""""""""""""""""""""""""

До виправлення:

.. code-block:: c

	char *buf = kmalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Після виправлення:

.. code-block:: c

	char *buf = kzalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Кодова база ядра містить багато функцій, які виділяють пам'ять за допомогою **kmalloc ()**, а потім обнуляют її за допомогою **memset ()**. Згодом Пекка Енберг прийшов до висновку, що більшу частину цього коду можна очистити за допомогою **kcalloc ()**.

**kcalloc ()** має цей прототип:

.. code-block:: c

	void * kcalloc (size_t n, size_t size, unsigned int __nocast gfp_flags);

Але тут є один недолік: далеко не всі викликаючі абоненти фактично повинні виділити масив елементів, тому в більшості випадків додатковий аргумент **size_t n** не потрібно. Кожен екземпляр цього аргументу додає деякий об'єм до розміру ядра, і з часом цей простір збільшується. Тому Ендрю Мортон запропнував нове рішення створити ще одну функцію розподілу:

.. code-block:: c

	void * kzalloc (size_t size, unsigned int __nocast gfp_flags);

Ця функція повертає один обнулений елемент.

TODO: Add buffer read logic. Make sure seek operations work
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: c
	
	unsigned long copy_to_user (void __user *to,
 		const void *from,
		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі користувача;
		* **from** - адреса джерела в просторі ядра;
		* **n** - кількість байтів для копіювання.

Короткий опис:
	Тільки контекст користувача Ця функція може спати.
	Скопіюйте дані з простору ядра в простір користувача.
	Повертає кількість байтів, які неможливо скопіювати. При успіху це буде нуль.
	
TODO: Add buffer write logic. Make sure seek operations work
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Копіювання даних з постору користувача відбувається за допомогою наступної команди:

.. code-block:: c

	unsigned long copy_from_user (void* to,
 		const void __user *from,
 		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі ядра;
		* **from** - адреса джерела в просторі користувача;
		* **n** - кількість байтів для копіювання.



Короткий опис:
	Тільки для користувача контекст. Ця функція може спати. 
	Копіює дані з простору користувача в простір ядра.
	Повертає кількість байтів, які не вдалося скопіювати. У разі успіху це буде нуль.

Команда повертує **нульове** значення вразі успішного виконання. 
Написана функці наведена нижче:

.. code-block:: c



Для того, щоб запезпечувалося читання та запис в пристрій, вирішено добавити функцію `lseek()`_. 


TODO: add ioctl to append magic phrase to buffer conents to make these bees twerk
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

TODO: add ioctl to select buffer size
"""""""""""""""""""""""""""""""""""""

Було створено функцію ``static long cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)``. 
В ній реалізано операцію, коли визначаємо новий розмір нашого буфера

.. code-block:: c

	copy_from_user(&buffsize, (int *)arg, sizeof(buffsize));
	printk(KERN_INFO "Buffsize = %d\n", buffsize);	

Для цього в програмі user_space викликаємо ``ioctl(fd, SEL_BUF_SIZE, (int *) &num);`` та передаємо розмір буфера, та в якості другого параметру - потрібну операцію.

TODO: add stuff here to make module register itself in /dev
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Для того, щоб використовувати *character driver*, спершу слід зареєструвати його в системі. Потім - виставити його в *user space*.

* ``cdev_init()`` - ініціалізувати структуру **cdev**;
* ``cdev_add()`` - додати символьний пристрій до системи;
* ``class_create()`` - створює новий клас пристроїв для пристрою;
* ``device_create()`` - створює пристрій та реєструє його за допомогою *sysfs*.
	
Функції **cdev_init()** та **cdev_add()** виконують реєстрацію символьних пристроїв. 
Коли функція **cdev_add** успішно виконується, пристрій працює в режимі живого і ядро ​​може викликати свої операції.

Щоб отримати доступ до цього пристрою з простору користувача, слід створити вузол пристрою в ``/dev``. Для цього потрібно створити клас віртуального пристрою за допомогою **class_create()**, слід його зареєєструвати в  ``sysfs`` за допомогою функції **device_create()**. 
**device_create** створить файл пристрою в ``/dev``.

Для початку використання всіх вище перерахованих функцій потрібно підключити ``#include <linux/cdev.h>``, де і відбувається визначення структури, а також пов'язані з нею допоміжні функції.




Результати
__________
